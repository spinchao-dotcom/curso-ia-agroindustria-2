\documentclass[12pt, a4paper]{article}

% =====================================================
% PAQUETES BASE (XeLaTeX)
% =====================================================
\usepackage{fontspec}
\usepackage[spanish, es-tabla, es-noquoting]{babel}
\usepackage{amsmath, amsfonts, amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage[most]{tcolorbox}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{tikz}
\usetikzlibrary{arrows.meta, positioning}

% =====================================================
% GEOMETRÍA
% =====================================================
\geometry{
  top=2.5cm,
  bottom=2.5cm,
  left=2.5cm,
  right=3cm,
  headheight=15pt
}

% =====================================================
% COLORES PROFESIONALES
% =====================================================
\definecolor{primary}{RGB}{0, 51, 102}
\definecolor{accent}{RGB}{46, 139, 87}
\definecolor{danger}{RGB}{180, 0, 0}
\definecolor{terminalbg}{RGB}{28, 28, 28}
\definecolor{terminalfg}{RGB}{135, 255, 0}

% =====================================================
% CAJAS
% =====================================================
\newtcolorbox{agrobox}[1]{
  colback=accent!5!white,
  colframe=accent,
  title=#1,
  fonttitle=\bfseries,
  boxrule=0.6mm,
  arc=2mm,
  enhanced
}

\newtcolorbox{infobox}[1]{
  colback=primary!5!white,
  colframe=primary,
  title=#1,
  fonttitle=\bfseries,
  boxrule=0.6mm,
  arc=2mm,
  enhanced
}

\newtcolorbox{warningbox}[1]{
  colback=danger!5!white,
  colframe=danger,
  title=#1,
  fonttitle=\bfseries,
  boxrule=0.6mm,
  arc=2mm,
  enhanced
}

% =====================================================
% ESTILO DE CÓDIGO
% =====================================================
\lstdefinestyle{bashstyle}{
  backgroundcolor=\color{terminalbg},
  basicstyle=\ttfamily\footnotesize\color{terminalfg},
  breaklines=true,
  language=bash,
  showstringspaces=false,
  keywordstyle=\color{cyan},
  commentstyle=\color{gray!70}\itshape
}

% =====================================================
% ENCABEZADO
% =====================================================
\pagestyle{fancy}
\fancyhf{}
\lhead{\color{primary}\textbf{Semana 1: Linux + Bash + Git}}
\rhead{Cimientos Técnicos}
\rfoot{Página \thepage}

% =====================================================
% PORTADA
% =====================================================
\title{\Huge\textbf{Semana 1: El Entorno del Ingeniero}\\
\vspace{0.5cm}
\Large Linux, Shell Scripting y Control de Versiones}
\author{Curso IA Agroindustria 2026}
\date{Enero 2026}

\begin{document}

\maketitle
\thispagestyle{empty}

% =====================================================
% ABSTRACT
% =====================================================
\begin{abstract}
El 80\% del éxito de un proyecto de Inteligencia Artificial depende de la ingeniería de datos, automatización y reproducibilidad.
Esta semana aprenderás las herramientas fundamentales: terminal Linux, procesamiento de datos con pipes y control de versiones con Git.
\end{abstract}

\tableofcontents
\newpage

% =====================================================
% OBJETIVOS
% =====================================================
\section*{Objetivos de Aprendizaje}

Al finalizar esta semana podrás:

\begin{itemize}
\item Navegar y manipular archivos desde la terminal Linux sin GUI.
\item Construir pipelines de procesamiento de datos con pipes y \texttt{awk}.
\item Usar Git como bitácora científica de tus experimentos.
\item Automatizar tareas repetitivas con scripts Bash reproducibles.
\end{itemize}

\begin{infobox}{Tiempo estimado}
\textbf{En clase (4h):} Fases 1--3 (terminal + Git básico).\\
\textbf{Autoestudio:} Fases 4--5 (estructura de proyectos + Python desde terminal).
\end{infobox}

\newpage

% =====================================================
% PREFACIO
% =====================================================
\section*{Prefacio: Tu Laboratorio Digital}

Imagina una finca equipada con sensores que generan miles de registros diarios en archivos CSV comprimidos.
Abrir archivos manualmente no es una opción sostenible cuando los datos crecen.
La ciencia de datos comienza cuando automatizas, validas y documentas cada paso del flujo de trabajo.

\begin{infobox}{Principio Fundamental}
Un modelo que no puede reproducirse no es ciencia: es magia.
\end{infobox}

\newpage

% =====================================================
% FASE 1
% =====================================================
\section{Fase 1: Supervivencia en la Terminal}

La terminal es un lenguaje de programación declarativo para hablar con el sistema operativo.
Todo flujo de datos sigue la lógica:
\[
\text{entrada} \rightarrow \text{proceso} \rightarrow \text{salida}
\]

En esta fase aprenderás a orientarte en el sistema de archivos y manipular archivos como un científico de datos.

\subsection{Navegación Básica}

\begin{infobox}{Objetivo}
Aprender a saber dónde estás, qué archivos hay y cómo moverte entre carpetas de un proyecto de datos.
\end{infobox}

Comandos clave:

\begin{itemize}
\item \texttt{pwd}: muestra la ruta completa de la carpeta actual.
\item \texttt{ls -lh}: lista archivos con tamaños legibles.
\item \texttt{ls *.csv}: lista solo archivos CSV en la carpeta actual.
\item \texttt{cd carpeta}: cambia a una subcarpeta.
\item \texttt{cd ..}: sube un nivel en la jerarquía.
\item \texttt{cd \textasciitilde}: va a la carpeta personal del usuario.
\end{itemize}

\begin{lstlisting}[style=bashstyle]
# Ver en qué carpeta estás
pwd
/home/estudiante

# Listar el contenido de la carpeta actual
ls -lh
drwxr-xr-x 2 estudiante estudiante 4.0K ene 10 proyectos
-rw-r--r-- 1 estudiante estudiante 1.2M ene 10 sensores.csv

# Entrar a la carpeta del proyecto
cd proyectos
pwd
/home/estudiante/proyectos

# Listar solo archivos CSV
ls *.csv
sensores.csv resumen_mensual.csv
\end{lstlisting}

\begin{agrobox}{Ejercicio guiado (15 min)}
\begin{enumerate}
\item Crea una carpeta \texttt{proyecto\_ia} dentro de tu \texttt{\textasciitilde}.
\item Dentro de \texttt{proyecto\_ia}, crea las carpetas \texttt{data}, \texttt{scripts} y \texttt{reports}.
\item Usa \texttt{pwd} y \texttt{ls -lh} en cada paso para verificar que estás en la carpeta correcta.
\end{enumerate}
\end{agrobox}

\subsection{Gestión de Archivos}

\begin{infobox}{Objetivo}
Crear, copiar, mover y eliminar archivos y carpetas para organizar un proyecto de datos.
\end{infobox}

Comandos frecuentes:

\begin{itemize}
\item \texttt{mkdir -p ruta}: crea una carpeta (y las intermedias si no existen).
\item \texttt{touch archivo}: crea un archivo vacío o actualiza su fecha.
\item \texttt{cp origen destino}: copia archivos.
\item \texttt{mv origen destino}: mueve o renombra archivos.
\item \texttt{rm archivo}: elimina archivos.
\end{itemize}

\begin{lstlisting}[style=bashstyle]
# Crear estructura de carpetas del proyecto
mkdir -p proyecto_ia/data/raw
mkdir -p proyecto_ia/data/processed
mkdir -p proyecto_ia/scripts
mkdir -p proyecto_ia/reports

# Crear un archivo de notas vacío
cd proyecto_ia
touch notas_proyecto.md

# Copiar un CSV de sensores al directorio raw
cp ~/sensores.csv data/raw/sensores.csv

# Renombrar el archivo de notas
mv notas_proyecto.md README.md

# Eliminar un archivo (con confirmación si usas alias de seguridad)
rm data/raw/archivo_innecesario.csv
\end{lstlisting}

\begin{warningbox}{Advertencia}
\texttt{rm} elimina permanentemente. Usa siempre \texttt{rm -i} para que pregunte antes de borrar cada archivo.
Más adelante definiremos alias de seguridad.
\end{warningbox}

\begin{agrobox}{Ejercicio (20 min)}
Diseña la estructura de carpetas para un proyecto de monitoreo de humedad de suelo y crea:
\begin{itemize}
\item Una carpeta \texttt{figures} para gráficos.
\item Una carpeta \texttt{logs} para registros de ejecución.
\item Un archivo \texttt{TODO.md} en la raíz del proyecto.
\end{itemize}
\end{agrobox}

\subsection{Comandos Clave de Científico de Datos}

\begin{infobox}{Objetivo}
Medir uso de disco, buscar archivos de datos y operar sobre columnas de archivos CSV desde la terminal.
\end{infobox}

Comandos útiles:

\begin{itemize}
\item \texttt{du -sh *}: muestra el tamaño de cada archivo/carpeta.
\item \texttt{df -h}: muestra el espacio disponible en discos.
\item \texttt{find . -name "*.csv"}: busca archivos con extensión \texttt{.csv}.
\item \texttt{cut -d',' -f1}: extrae columnas de un CSV.
\item \texttt{sort | uniq}: ordena y elimina duplicados.
\end{itemize}

\begin{lstlisting}[style=bashstyle]
# Ver qué carpeta ocupa más espacio dentro de data
cd proyecto_ia/data
du -sh *

# Ver espacio disponible en el disco
df -h

# Buscar todos los archivos CSV en el proyecto
cd ..
find . -name "*.csv"

# Extraer la primera columna (por ejemplo, id_sensor) de un CSV
cd data/raw
cut -d',' -f1 sensores.csv | head

# Obtener lista única de sensores
cut -d',' -f1 sensores.csv | sort | uniq | head
\end{lstlisting}

\begin{agrobox}{Ejercicio aplicado (25 min)}
Supón que \texttt{sensores.csv} tiene columnas \texttt{id\_sensor,fecha,temperatura,humedad}.
\begin{enumerate}
\item Obtén la lista única de \texttt{id\_sensor} ordenada alfabéticamente.
\item Cuenta cuántos registros totales tiene el archivo.
\item Calcula cuántos registros hay por cada \texttt{id\_sensor} usando \texttt{sort | uniq -c}.
\end{enumerate}
\end{agrobox}

\newpage

% =====================================================
% FASE 2
% =====================================================
\section{Fase 2: Procesamiento y Automatización}

En esta fase aprenderás a inspeccionar datos reales, detectar errores frecuentes y construir pequeños pipelines de procesamiento usando la terminal.

\subsection{Inspección de Datos}

\begin{infobox}{Objetivo}
Inspeccionar rápidamente el contenido de archivos grandes sin abrirlos en un editor gráfico.
\end{infobox}

Comandos:

\begin{itemize}
\item \texttt{head -n 5 datos.csv}: muestra las primeras 5 líneas.
\item \texttt{tail -n 5 datos.csv}: muestra las últimas 5 líneas.
\item \texttt{wc -l datos.csv}: cuenta las líneas del archivo.
\item \texttt{less datos.csv}: permite navegar por el archivo.
\end{itemize}

\begin{lstlisting}[style=bashstyle]
# Ver las primeras líneas de sensores.csv
cd proyecto_ia/data/raw
head -n 5 sensores.csv

# Ver las últimas líneas (útil para ver fechas recientes)
tail -n 5 sensores.csv

# Contar cuántos registros hay
wc -l sensores.csv

# Navegar por el archivo (q para salir)
less sensores.csv
\end{lstlisting}

\subsection{Datos Reales y Errores Comunes}

Los datos reales contienen errores:

\begin{itemize}
\item Valores faltantes representados como cadenas vacías o símbolos especiales.
\item Separadores inconsistentes (comas, punto y coma, tabuladores).
\item Registros corruptos con caracteres no ASCII.
\end{itemize}

\begin{lstlisting}[style=bashstyle]
# Buscar columnas vacías consecutivas ,, que pueden indicar datos faltantes
grep ",," sensores.csv | head

# Detectar caracteres no ASCII (posibles errores de codificación)
grep -P "[^\x00-\x7F]" sensores.csv | head
\end{lstlisting}

\begin{warningbox}{Atención}
Antes de entrenar cualquier modelo, debes conocer la calidad de tus datos.
No confíes en que el archivo está limpio solo porque se abre en una hoja de cálculo.
\end{warningbox}

\subsection{Pipelines con Pipes}

El operador \texttt{|} (pipe) conecta la salida de un comando con la entrada de otro.
Permite encadenar operaciones simples para construir un procesamiento más complejo.

\begin{lstlisting}[style=bashstyle]
# Contar cuántas veces aparece cada id_sensor en el archivo
cut -d',' -f1 sensores.csv | sort | uniq -c | sort -nr | head

# Obtener los 10 valores de temperatura más altos registrados
cut -d',' -f3 sensores.csv | sort -nr | head

# Filtrar solo las líneas de un sensor específico y contarlas
grep "SENSOR_05" sensores.csv | wc -l
\end{lstlisting}

\begin{agrobox}{Ejercicio de pipeline (30 min)}
Construye un pipeline que:
\begin{enumerate}
\item Se quede solo con las columnas \texttt{id\_sensor,temperatura}.
\item Ordene por temperatura descendente.
\item Muestre las 5 mediciones más altas por pantalla.
\end{enumerate}
\end{agrobox}

\subsection{Procesamiento con awk}

\texttt{awk} es un mini-lenguaje para procesar texto y columnas; permite calcular estadísticas básicas directamente desde la terminal.

\begin{lstlisting}[style=bashstyle]
# Calcular la temperatura promedio (suponiendo que está en la columna 3)
awk -F',' '{s+=$3} END {print "Temperatura promedio:", s/NR}' sensores.csv

# Calcular la humedad máxima (columna 4)
awk -F',' 'NR>1 {if($4>max) max=$4} END {print "Humedad máxima:", max}' sensores.csv

# Filtrar solo filas con humedad menor a 30
awk -F',' '$4 < 30 {print $0}' sensores.csv | head
\end{lstlisting}

\begin{agrobox}{Ejercicio con awk (30 min)}
\begin{enumerate}
\item Usa \texttt{awk} para calcular la temperatura mínima.
\item Calcula la suma total de registros donde \texttt{humedad < 40}.
\item Guarda las filas con \texttt{humedad > 80} en un archivo \texttt{alertas\_humedad.csv}.
\end{enumerate}
\end{agrobox}

\newpage

% =====================================================
% FASE 3
% =====================================================
\section{Fase 3: Control de Versiones con Git}

En esta fase transformarás tu carpeta de archivos sueltos en un proyecto versionado con Git, usando buenas prácticas de colaboración.

\subsection{Git como Bitácora Científica}

Git es un sistema de control de versiones distribuido que registra la historia de tu proyecto, permitiéndote volver a estados anteriores y colaborar con otros.

Flujo básico:

\begin{enumerate}
\item \texttt{git init}: inicializa el repositorio.
\item \texttt{git status}: muestra el estado actual.
\item \texttt{git add}: selecciona cambios para guardar.
\item \texttt{git commit}: guarda un "fotograma" con mensaje.
\end{enumerate}

\begin{lstlisting}[style=bashstyle]
cd ~/proyecto_ia

# Inicializar repositorio Git
git init

# Ver estado (archivos sin seguimiento)
git status

# Añadir todos los archivos para el primer commit
git add .

# Crear el commit inicial con un mensaje descriptivo
git commit -m "feat: estructura inicial del proyecto de sensores"

# Ver el historial de commits
git log --oneline
\end{lstlisting}

\begin{infobox}{Buenas prácticas de commits}
\begin{itemize}
\item Haz commits pequeños y frecuentes.
\item Usa mensajes que expliquen el \emph{por qué} del cambio.
\item Agrupa cambios relacionados en un mismo commit.
\item Usa prefijos: \texttt{feat:}, \texttt{fix:}, \texttt{docs:}, \texttt{refactor:}.
\end{itemize}
\end{infobox}

\subsection{Uso de .gitignore}

El archivo \texttt{.gitignore} indica a Git qué archivos o carpetas no deben versionarse (datos brutos, modelos grandes, archivos temporales).

\begin{lstlisting}[style=bashstyle]
# Crear el archivo .gitignore
cat > .gitignore << EOF
# Entornos virtuales
venv/
ia_env/

# Datos brutos (no versionables)
data/raw/
data/interim/

# Artefactos Python
*.pyc
__pycache__/
.ipynb_checkpoints/

# Modelos pesados
*.pth
*.h5

# Logs y temporales
*.log
*.tmp
EOF

git add .gitignore
git commit -m "docs: configura .gitignore para datos y artefactos"
\end{lstlisting}

\begin{warningbox}{Regla práctica}
Nunca subas datos sensibles ni archivos de gran tamaño al repositorio.
Para datos grandes, considera herramientas como Git LFS u otros almacenes externos.
\end{warningbox}

\subsection{Flujo de Trabajo Básico}

\begin{lstlisting}[style=bashstyle]
# Modificar un archivo (por ejemplo, agregar un script)
echo "#!/bin/bash" > scripts/validar_datos.sh
echo "wc -l data/raw/*.csv" >> scripts/validar_datos.sh
chmod +x scripts/validar_datos.sh

# Ver qué cambió
git status
git diff scripts/validar_datos.sh

# Registrar el cambio
git add scripts/validar_datos.sh
git commit -m "feat: script de validación de registros"

# Ver historial
git log --oneline --graph
\end{lstlisting}

\begin{agrobox}{Ejercicio de Git (30 min)}
\begin{enumerate}
\item Inicializa un repositorio en \texttt{proyecto\_ia}.
\item Haz un commit inicial con la estructura de carpetas.
\item Crea un script \texttt{scripts/resumen.sh} que cuente archivos CSV y haz commit.
\item Modifica el README y haz otro commit con mensaje descriptivo.
\item Usa \texttt{git log} para ver tu historial.
\end{enumerate}
\end{agrobox}

\newpage

% =====================================================
% CASOS POR CARRERA
% =====================================================
\section{Casos de Uso por Carrera}

Los comandos aprendidos se aplican distinto según el dominio:

\subsection{Agroindustria Alimenticia}

\begin{agrobox}{Caso: Control de calidad de lotes}
Archivos CSV con registros de inspección visual (color, tamaño, defectos) de fruta para exportación.
Cada fila = 1 unidad inspeccionada, con columnas: \texttt{lote\_id,fecha,peso\_g,calibre,color,defectos}.

\textbf{Pipeline típico:}
\begin{lstlisting}[style=bashstyle]
# Cuántos lotes inspeccionados hoy
grep "$(date +%Y-%m-%d)" inspeccion.csv | cut -d',' -f1 | sort | uniq | wc -l

# Lotes con >5% de defectos (columna 6 > 5)
awk -F',' '$6 > 5 {print $1}' inspeccion.csv | sort | uniq > lotes_rechazados.txt
\end{lstlisting}
\end{agrobox}

\subsection{Agronomía}

\begin{agrobox}{Caso: Monitoreo de rendimiento por lote}
CSV con datos de cosecha: \texttt{lote\_id,ha,kg\_cosechados,fecha}.

\textbf{Pipeline típico:}
\begin{lstlisting}[style=bashstyle]
# Calcular toneladas/ha promedio por lote
awk -F',' 'NR>1 {print $1, $3/$2/1000}' cosecha.csv | \
  awk '{s[$1]+=$2; c[$1]++} END {for(l in s) print l, s[l]/c[l]}' | \
  sort -k2 -nr > rendimiento_promedio.txt
\end{lstlisting}
\end{agrobox}

\subsection{Ingeniería Agrícola}

\begin{agrobox}{Caso: Telemetría de riego}
Datos de sensores de humedad cada 15 min: \texttt{sensor\_id,timestamp,humedad\_suelo,presion\_agua}.

\textbf{Pipeline típico:}
\begin{lstlisting}[style=bashstyle]
# Detectar sensores con humedad <20% (alerta riego)
awk -F',' '$3 < 20 {print $1,$2,$3}' riego.csv | \
  sort | uniq > alertas_riego.txt

# Contar alertas por sensor
cut -d' ' -f1 alertas_riego.txt | sort | uniq -c | sort -nr
\end{lstlisting}
\end{agrobox}

\subsection{Ingeniería Ambiental}

\begin{agrobox}{Caso: Monitoreo de calidad de agua}
CSV con muestreos: \texttt{estacion\_id,fecha,pH,turbidez\_NTU,coliformes\_UFC}.

\textbf{Pipeline típico:}
\begin{lstlisting}[style=bashstyle]
# Estaciones fuera de norma (pH <6.5 o >8.5)
awk -F',' '$3<6.5 || $3>8.5 {print $1,$2,$3}' calidad_agua.csv > pH_fuera_norma.txt

# Promedios de turbidez por estación
awk -F',' 'NR>1 {s[$1]+=$4; c[$1]++} END {for(e in s) print e, s[e]/c[e]}' \
  calidad_agua.csv | sort -k2 -nr
\end{lstlisting}
\end{agrobox}

\begin{infobox}{Ejercicio multi-carrera (30 min)}
Adapta uno de estos pipelines a tu dataset real (o simula uno pequeño con 20 filas en Excel y exporta a CSV).
Documenta en tu README qué hizo cada comando y qué insights descubriste.
\end{infobox}

\newpage

% =====================================================
% ENTREGABLE A1
% =====================================================
\section{Entregable A1: Script de Setup Reproducible}

\begin{infobox}{Objetivo}
Construir un script Bash (\texttt{scripts/setup\_proyecto.sh}) que automatice la creación de estructura, descarga de datos (muestra) y validación básica.
\end{infobox}

\subsection{Requisitos Mínimos}

\begin{enumerate}
\item Crea estructura de carpetas (\texttt{data/raw}, \texttt{data/processed}, \texttt{scripts}, \texttt{reports}).
\item Descarga un CSV pequeño de ejemplo (puedes usar \texttt{wget} o \texttt{curl} a una URL pública, o copiarlo de tu carpeta personal).
\item Genera un reporte en \texttt{reports/validacion\_inicial.txt} que contenga:
  \begin{itemize}
  \item Número de filas (\texttt{wc -l}).
  \item Número de columnas (\texttt{head -n1 | tr ',' '\textbackslash n' | wc -l}).
  \item Verificación de valores faltantes (\texttt{grep ",,"}).
  \end{itemize}
\item Registra todo en Git con al menos 3 commits significativos.
\end{enumerate}

\begin{warningbox}{Criterios de Evaluación}
\begin{itemize}
\item El script debe ser \textbf{idempotente}: ejecutarlo varias veces no rompe nada.
\item Usa \texttt{mkdir -p} y valida si el archivo ya existe antes de descargar.
\item Mensajes de commit claros con prefijos ("feat:", "fix:", "docs:").
\item Incluye un \texttt{README.md} con instrucciones de uso del script.
\end{itemize}
\end{warningbox}

\subsection{Estructura Esperada del Repositorio}

\begin{verbatim}
proyecto_ia/
├── data/
│   ├── raw/
│   │   └── datos_sensores.csv
│   └── processed/
├── scripts/
│   └── setup_proyecto.sh
├── reports/
│   └── validacion_inicial.txt
├── .gitignore
└── README.md
\end{verbatim}

\subsection{Plantilla del Script}

\begin{lstlisting}[style=bashstyle]
#!/usr/bin/env bash
set -euo pipefail

# Crear estructura
mkdir -p data/raw data/processed scripts reports

# Descargar datos (ejemplo)
DATA_URL="https://ejemplo.com/datos.csv"
DATA_FILE="data/raw/datos_sensores.csv"

if [ ! -f "$DATA_FILE" ]; then
  echo "Descargando datos..."
  curl -o "$DATA_FILE" "$DATA_URL"
fi

# Validar datos
echo "=== Reporte de Validación ===" > reports/validacion_inicial.txt
echo "Fecha: $(date)" >> reports/validacion_inicial.txt
echo "Filas: $(wc -l < $DATA_FILE)" >> reports/validacion_inicial.txt
echo "Columnas: $(head -n1 $DATA_FILE | tr ',' '\n' | wc -l)" >> reports/validacion_inicial.txt
echo "Valores faltantes: $(grep -c ",," $DATA_FILE || true)" >> reports/validacion_inicial.txt

echo "Setup completado. Ver reports/validacion_inicial.txt"
\end{lstlisting}

\subsection{Entrega}

\begin{itemize}
\item Sube tu repositorio a GitHub (público o con acceso al docente).
\item Comparte la URL en el formulario del curso.
\item Asegúrate de que el repositorio tenga al menos 3 commits con mensajes claros.
\end{itemize}

\textbf{Bonus (opcional):}
Añade una llamada a Python al final del script para generar estadísticas descriptivas de columnas numéricas y guardarlas en \texttt{reports/estadisticas.csv}.

\newpage

% =====================================================
% AUTOESTUDIO
% =====================================================
\section*{Material de Autoestudio}

\subsection*{Fase 4: Estructura de Proyectos Reproducibles}

Una buena estructura de proyecto permite que cualquier persona entienda dónde están los datos, el código, los modelos y los reportes.

\begin{verbatim}
proyecto_ia/
├── data/
│   ├── raw/          # datos brutos (no limpios)
│   └── processed/    # datos listos para análisis/modelado
├── scripts/          # scripts de limpieza, descarga, validación
├── notebooks/        # cuadernos exploratorios (Jupyter)
├── models/           # modelos entrenados y artefactos
├── reports/          # informes, figuras y tablas
└── README.md         # descripción del proyecto
\end{verbatim}

\subsection*{Fase 5: Integración con Python}

Puedes llamar Python desde la terminal para análisis más avanzados:

\begin{lstlisting}[style=bashstyle]
# Ejecutar análisis directo
python - << EOF
import pandas as pd
df = pd.read_csv("data/raw/sensores.csv")
print(df.describe())
print("Temperatura promedio:", df["temperatura"].mean())
EOF
\end{lstlisting}

\subsection*{Entornos Virtuales de Python}

\begin{lstlisting}[style=bashstyle]
# Crear entorno virtual
python -m venv ia_env

# Activar (Linux/macOS)
source ia_env/bin/activate

# Instalar dependencias
pip install pandas numpy matplotlib

# Congelar versiones
pip freeze > requirements.txt

# Desactivar
deactivate
\end{lstlisting}

\appendix

\section*{Anexo: Alias de Seguridad}

\begin{lstlisting}[style=bashstyle]
# Agregar a ~/.bashrc o ~/.zshrc
alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'
alias ll='ls -lh'
alias la='ls -lha'
alias gs='git status'
alias gl='git log --oneline --graph'
\end{lstlisting}

\begin{infobox}{Siguiente Nivel}
En Semana 2 aprenderás vectorización con NumPy y procesamiento eficiente de datasets grandes (>1M filas).
Docker y despliegue se cubren en Semana 7-8 (MLOps).
\end{infobox}

\end{document}
