\documentclass[11pt, a4paper]{article}

% --- MOTOR DE FUENTES (XeLaTeX) ---
\usepackage{fontspec}
\setmainfont{DejaVu Sans}[
  BoldFont={DejaVu Sans Bold},
  ItalicFont={DejaVu Sans Oblique},
  Scale=0.95
]
\setmonofont{DejaVu Sans Mono}[Scale=0.85]

% --- IDIOMA ---
\usepackage{polyglossia}
\setmainlanguage{spanish}

% --- PAQUETES ---
\usepackage{geometry}
\usepackage{xcolor}
\usepackage{listings}
\usepackage[most]{tcolorbox}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}

% --- GEOMETR√çA ---
\geometry{top=2.5cm, bottom=2.5cm, left=2.5cm, right=3.2cm}
\setlength{\headheight}{28pt}

% --- COLORES ---
\definecolor{primary}{RGB}{0, 85, 164}
\definecolor{accent}{RGB}{34, 139, 34}
\definecolor{danger}{RGB}{204, 0, 0}
\definecolor{codebg}{RGB}{245, 247, 250}
\definecolor{muted}{RGB}{90, 90, 90}

% --- CAJAS ---
\newtcolorbox{conceptbox}[1]{
  colback=blue!5!white,
  colframe=primary,
  title=#1,
  fonttitle=\bfseries,
  boxrule=0.5mm,
  arc=2mm,
  enhanced
}
\newtcolorbox{agrobox}[1]{
  colback=green!5!white,
  colframe=accent,
  title=#1,
  fonttitle=\bfseries,
  boxrule=0.5mm,
  arc=2mm,
  enhanced
}
\newtcolorbox{warningbox}[1]{
  colback=red!5!white,
  colframe=danger,
  title=#1,
  fonttitle=\bfseries,
  boxrule=0.5mm,
  arc=2mm,
  enhanced
}

% --- LISTINGS (Python) ---
\lstdefinestyle{pythonstyle}{
  backgroundcolor=\color{codebg},
  commentstyle=\color{muted}\itshape,
  keywordstyle=\color{primary}\bfseries,
  numberstyle=\tiny\color{muted},
  stringstyle=\color{accent},
  basicstyle=\ttfamily\footnotesize,
  breaklines=true,
  frame=l,
  rulecolor=\color{primary},
  numbers=left,
  showstringspaces=false,
  literate=
  {√°}{{\'a}}1 {√©}{{\'e}}1 {√≠}{{\'i}}1 {√≥}{{\'o}}1 {√∫}{{\'u}}1 {√±}{{\~n}}1
  {‚ö†}{{\textcolor{orange}{\bfseries !}}}1
  {üíß}{{\textcolor{blue}{O}}}1
  {‚úÖ}{{\textcolor{green}{OK}}}1
  {‚Äî}{{--}}1
  {‚Äì}{{--}}1
}
\lstset{style=pythonstyle}

% --- ENCABEZADO ---
\pagestyle{fancy}
\fancyhf{}
\lhead{\textbf{Ingenier√≠a de IA I}}
\rhead{Semana 02: HPC con Python + NumPy}
\rfoot{\thepage}

\title{\textbf{Semana 02 ‚Äî Computaci√≥n Cient√≠fica y HPC para el Agro}\\
\large Desarrollo + ejemplos comentados + ejercicios}
\author{Curso de IA Aplicada al Agro}
\date{Enero 2026}

\begin{document}

\maketitle
\tableofcontents
\newpage
% =====================================================
% Cap√≠tulo 1 (Intro): Puente desde Python b√°sico a HPC/NumPy
% =====================================================
\section{Cap√≠tulo 1: De Python b√°sico a NumPy (el puente conceptual)}

Este cap√≠tulo es una gu√≠a corta para que cualquier estudiante, incluso si apenas est√° empezando, entienda el \textbf{por qu√©} y el \textbf{para qu√©} de lo que vamos a construir en esta semana: validaci√≥n de datos, limpieza de CSV, medici√≥n de rendimiento y procesamiento matricial con NumPy.

\begin{conceptbox}{Meta del cap√≠tulo}
Al finalizar este cap√≠tulo deber√≠as poder leer el resto del manual sin sentir que ``aparecen cosas m√°gicas''. La idea es entender:
\begin{itemize}
\item Qu√© es un programa en Python y c√≥mo se organiza.
\item C√≥mo se toman decisiones (\texttt{if/elif/else}) y se repiten tareas (\texttt{for}).
\item Por qu√© usamos funciones para empaquetar l√≥gica.
\item C√≥mo funcionan los errores y por qu√© los usamos (fail fast).
\item C√≥mo leer archivos de texto/CSV de manera simple.
\item Por qu√© NumPy cambia el juego en rendimiento (vectorizaci√≥n).
\item Qu√© son m√°scaras booleanas y c√≥mo \texttt{np.where} decide por celda.
\end{itemize}
\end{conceptbox}

\subsection{Qu√© es un programa en Python (y qu√© significa ``ejecutar'')}
Un programa en Python es un archivo \texttt{.py} con instrucciones que la m√°quina ejecuta en orden.
En este curso, casi todos los scripts siguen esta estructura:

\begin{lstlisting}[language=Python, caption={Estructura t√≠pica de un script}]
def main():
    # aqu√≠ va la l√≥gica principal
    print("Hola")

if __name__ == "__main__":
    main()
\end{lstlisting}

\textbf{Idea clave:} \texttt{main()} concentra el flujo del programa y el bloque
\texttt{if \_\_name\_\_ == "\_\_main\_\_":}
 hace que el script se ejecute solo cuando lo corres directamente.

\subsection{Tipos de datos: n√∫meros, texto y booleanos}
Para trabajar con sensores y mediciones necesitamos entender tres tipos b√°sicos:

\begin{itemize}
\item \textbf{N√∫meros}: \texttt{int} y \texttt{float} (ej. temperatura, humedad).
\item \textbf{Texto}: \texttt{str} (ej. id del sensor, fecha).
\item \textbf{Booleanos}: \texttt{True/False} (ej. ``est√° en sequ√≠a?'' s√≠/no).
\end{itemize}

\begin{lstlisting}[language=Python, caption={Ejemplo m√≠nimo de tipos}]
temp = 24.2          # float
hum = 55             # int
sensor_id = "SENSOR_01"  # str
alarma = hum < 40     # bool
\end{lstlisting}

\section{Verificar y convertir tipos de datos en Python}

En programaci√≥n cient√≠fica es fundamental asegurarse de que cada variable tenga el \textbf{tipo de dato} correcto (entero, n√∫mero real, texto, etc.), especialmente antes de hacer c√°lculos o comparaciones.

\subsection{Tipos b√°sicos: \texttt{int}, \texttt{float}, \texttt{str}}

En Python, los tipos m√°s usados en este curso son:

\begin{itemize}
    \item \texttt{int}: n√∫meros enteros, por ejemplo \texttt{3}, \texttt{-10}, \texttt{42}.
    \item \texttt{float}: n√∫meros reales (con decimales), por ejemplo \texttt{3.14}, \texttt{-0.5}, \texttt{25.0}.
    \item \texttt{str}: cadenas de texto, por ejemplo \texttt{"Caf√©"}, \texttt{"Zona Norte"}, \texttt{"25.0"}.
\end{itemize}

\subsection{C√≥mo saber de qu√© tipo es una variable}

Python permite inspeccionar el tipo de una variable con la funci√≥n \texttt{type()}:

\begin{lstlisting}[language=Python, caption={Inspecci√≥n de tipos de variables}]
temperatura = 25.0
parcela_id = "P001"
cantidad_sacos = 30

print(type(temperatura))   # <class 'float'>
print(type(parcela_id))    # <class 'str'>
print(type(cantidad_sacos))# <class 'int'>
\end{lstlisting}

Esto es √∫til para depurar errores cuando una operaci√≥n no funciona como se esperaba.

\subsection{Convertir entre tipos (casting)}

Muchas veces los datos llegan como texto (\texttt{str}) desde un archivo CSV o desde la entrada del usuario, y es necesario convertirlos a n√∫mero antes de operar.

\begin{lstlisting}[language=Python, caption={Conversi√≥n de tipos}]
valor_bruto = "28.5"   # Esto es texto, no un n√∫mero

temperatura = float(valor_bruto)  # str -> float
sacos_str = "30"
sacos = int(sacos_str)            # str -> int

print(temperatura + 1.5)          # 30.0
print(sacos + 5)                  # 35
\end{lstlisting}

Conversi√≥n t√≠pica en este curso:

\begin{itemize}
    \item \texttt{str} a \texttt{int}: \texttt{int("42")}.
    \item \texttt{str} a \texttt{float}: \texttt{float("3.14")}.
    \item Cualquier tipo a \texttt{str}: \texttt{str(25.0)}.
\end{itemize}

\subsection{Ejemplo aplicado al agro}

Al leer un CSV con mediciones de parcelas, todas las columnas llegan como texto. Antes de tomar decisiones agron√≥micas, se convierten al tipo correcto:

\begin{lstlisting}[language=Python, caption={Asegurar tipos correctos desde CSV}]
fila = {
    "parcela_id": "P010",
    "temperatura_c": "29.7",
    "humedad_suelo_pct": "38",
    "ph": "5.4"
}

parcela_id = fila["parcela_id"]                 # str
temperatura = float(fila["temperatura_c"])      # str -> float
humedad = int(fila["humedad_suelo_pct"])        # str -> int
ph = float(fila["ph"])                          # str -> float

print(type(parcela_id))  # <class 'str'>
print(type(temperatura)) # <class 'float'>
print(type(humedad))     # <class 'int'>
print(type(ph))          # <class 'float'>
\end{lstlisting}

Si se omite esta conversi√≥n, las comparaciones como \texttt{temperatura > 30} o \texttt{humedad < 40} pueden fallar o producir resultados incorrectos.

\section{Control de flujo: decisiones y reglas}
Las reglas agron√≥micas se expresan como condiciones:

\begin{lstlisting}[language=Python, caption={Decisi√≥n simple con if/elif/else}]
if hum < 40:
    print("Riego")
elif hum > 80:
    print("Drenaje")
else:
    print("Normal")
\end{lstlisting}

\textbf{Puente al manual:} m√°s adelante no aplicaremos estas reglas a un solo valor, sino a una matriz completa con NumPy.

\subsection{Repetici√≥n: recorrer muchos datos}
Cuando hay m√∫ltiples sensores o m√∫ltiples filas en un archivo, repetimos acciones:

\begin{lstlisting}[language=Python, caption={Recorrer una lista con for}]
humedades = [55, 60, 38, 92]
for h in humedades:
    if h < 40:
        print("Riego")
\end{lstlisting}

\textbf{Puente al manual:} recorrer 1,000,000 valores con un \texttt{for} es posible, pero lento; por eso aparece NumPy.

\subsection{Estructuras clave: listas y diccionarios}
En IA aplicada al agro se usan mucho:

\begin{itemize}
\item \textbf{Listas}: colecciones ordenadas (series de mediciones).
\item \textbf{Diccionarios}: registros con campos (una fila de sensor con columnas).
\end{itemize}

\begin{lstlisting}[language=Python, caption={Registro tipo diccionario (una fila de sensor)}]
row = {"id": "SENSOR_01", "temp": 24.2, "hum": 55}
\end{lstlisting}

\textbf{Puente al manual:} el validador fail-fast trabaja sobre diccionarios as√≠.

\section{Funciones: empaquetar l√≥gica reutilizable}
Cuando una regla se repite, se convierte en funci√≥n:

\begin{lstlisting}[language=Python, caption={Funci√≥n simple reutilizable}]
def necesita_riego(hum):
    return hum < 40

print(necesita_riego(35))  # True
\end{lstlisting}

\textbf{Puente al manual:} \texttt{validar\_sensor\_row(row)} es una funci√≥n que formaliza una pol√≠tica de calidad de datos.

\subsection{Errores y excepciones: fail fast en la pr√°ctica}
En ingenier√≠a, a veces la respuesta correcta es \textbf{parar}.

\begin{lstlisting}[language=Python, caption={Excepciones con try/except}]
def dividir(a, b):
    if b == 0:
        raise ValueError("No se puede dividir por cero")
    return a / b

try:
    print(dividir(10, 0))
except ValueError as e:
    print("Error:", e)
\end{lstlisting}

\textbf{Puente al manual:} cuando una fila del CSV est√° corrupta o fuera de rango, la descartamos y registramos el motivo; eso evita contaminar resultados.

\subsection{Archivos: leer texto y CSV sin librer√≠as}
Un CSV es texto con comas. Podemos procesarlo l√≠nea por l√≠nea:

\begin{lstlisting}[language=Python, caption={Lectura m√≠nima de un CSV (sin pandas)}]
with open("sensores.csv", "r", encoding="utf-8") as f:
    header = f.readline()  # primera l√≠nea: nombres de columnas
    for linea in f:
        partes = linea.strip().split(",")
        # aqu√≠ validas y conviertes tipos
\end{lstlisting}

\textbf{Puente al manual:} ese patr√≥n es la base de la limpieza del CSV sucio y la escritura del CSV limpio.

\section{Por qu√© NumPy: cuando el tama√±o importa}
Python es excelente para l√≥gica, pero un \texttt{for} ejecuta iteraci√≥n por iteraci√≥n en el int√©rprete.
NumPy permite operar con arreglos completos de n√∫meros de forma eficiente (operaciones implementadas en bajo nivel).

\begin{conceptbox}{Idea}
En el manual medimos esto con un benchmark:
\begin{itemize}
\item versi√≥n lenta: bucle \texttt{for}
\item versi√≥n r√°pida: \texttt{np.sin(x) + np.cos(x)}
\end{itemize}
\end{conceptbox}

\subsection{M√°scaras booleanas: decisiones sobre mapas}
Una m√°scara booleana es una matriz de \texttt{True/False} que marca posiciones de inter√©s:

\begin{lstlisting}[language=Python, caption={M√°scara booleana en matriz}]
import numpy as np
humedad = np.random.rand(5, 5)
sequia = humedad < 0.2  # matriz booleana del mismo tama√±o
\end{lstlisting}

Esto permite seleccionar/contar/actuar sobre celdas sin iterar manualmente.

\subsection{\texttt{np.where}: decidir por celda sin if por celda}
\texttt{np.where(condicion, valor\_si\_true, valor\_si\_false)} construye una salida celda-a-celda.

\begin{lstlisting}[language=Python, caption={np.where como motor de decisiones}]
acciones = np.where(humedad < 0.2, "R", ".")  # "R" regar, "." normal
\end{lstlisting}

\textbf{Puente al manual:} esto es el n√∫cleo del ‚Äúmotor de decisi√≥n h√≠drica‚Äù sobre mapas.

% =====================================================
% Secci√≥n extra: Profundizaci√≥n en NumPy
% =====================================================
\section{Profundizaci√≥n: NumPy y su potencial}

Esta secci√≥n ampl√≠a NumPy m√°s all√° de ``hacer matrices'': el objetivo es dominar las ideas que hacen a NumPy la base de casi todo en ciencia de datos y ML: \textbf{arrays}, \textbf{formas (shape)}, \textbf{tipos (dtype)}, \textbf{operaciones vectorizadas (ufuncs)}, \textbf{broadcasting} y \textbf{m√°scaras}.

\subsection{El objeto central: \texttt{ndarray} (shape y dtype)}
Un \texttt{ndarray} es un arreglo multidimensional homog√©neo: todos los elementos tienen el mismo tipo num√©rico (\texttt{dtype}).
Dos propiedades mandan:
\begin{itemize}
\item \textbf{shape}: cu√°ntas filas/columnas (o dimensiones) tiene.
\item \textbf{dtype}: tipo de dato (float64, int32, etc.).
\end{itemize}

\begin{lstlisting}[language=Python, caption={Crear arrays y observar shape/dtype}]
import numpy as np

a = np.array([1, 2, 3])          # 1D
b = np.array([[1.0, 2.0], [3.0, 4.0]])  # 2D

print(a.shape, a.dtype)
print(b.shape, b.dtype)
\end{lstlisting}

\begin{conceptbox}{Idea pr√°ctica}
\texttt{shape} te dice el ``tama√±o geom√©trico'' de tus datos; \texttt{dtype} te dice el ``costo'' en memoria y qu√© operaciones son posibles.
\end{conceptbox}

\subsection{Creaci√≥n eficiente de arrays}
Algunas formas t√≠picas de crear datos:
\begin{itemize}
\item \texttt{np.zeros}, \texttt{np.ones}: inicializaci√≥n r√°pida.
\item \texttt{np.arange}, \texttt{np.linspace}: secuencias num√©ricas.
\item \texttt{np.random.rand}: simulaci√≥n/ruido (para pruebas).
\end{itemize}

\begin{lstlisting}[language=Python, caption={Creaci√≥n r√°pida de matrices}]
import numpy as np

Z = np.zeros((3, 4))       # matriz 3x4 llena de 0
O = np.ones((2, 2))        # matriz 2x2 llena de 1
x = np.arange(0, 10)       # [0..9]
t = np.linspace(0, 1, 5)   # 5 puntos entre 0 y 1
\end{lstlisting}

\subsection{Indexing y slicing (leer sub-zonas del lote)}
Piensa una matriz como un mapa del lote: puedes seleccionar sub-regiones con slicing.

\begin{lstlisting}[language=Python, caption={Slicing en 2D: sub-zona del mapa}]
import numpy as np

humedad = np.random.rand(100, 100)

zona_centro = humedad[40:60, 40:60]   # 20x20
primera_fila = humedad[0, :]          # 100 valores
primera_col = humedad[:, 0]           # 100 valores
\end{lstlisting}

\begin{warningbox}{Error com√∫n}
En NumPy, el orden es \texttt{[filas, columnas]}.
\end{warningbox}

\section{Vectorizaci√≥n con ufuncs: ``sin for''}
Las operaciones element-wise (por elemento) se aplican a todo el array:
\begin{lstlisting}[language=Python, caption={Ufuncs: operaciones vectorizadas}]
import numpy as np

x = np.random.rand(5)
y = np.sin(x) + np.cos(x)  # aplica a todo el vector
\end{lstlisting}

\begin{conceptbox}{Conexi√≥n con HPC}
Esto es la base del benchmark del manual: mover el trabajo del int√©rprete (loop Python) a operaciones vectorizadas.
\end{conceptbox}

\subsection{Broadcasting: el superpoder}
Broadcasting describe c√≥mo NumPy trata arreglos de diferentes shapes en operaciones aritm√©ticas; el arreglo peque√±o se ``expande'' l√≥gicamente para ser compatible, evitando bucles expl√≠citos y usualmente sin copias innecesarias.

\begin{lstlisting}[language=Python, caption={Broadcasting: sumar vector a cada fila}]
import numpy as np

A = np.random.rand(3, 4)  # 3x4
b = np.array([10, 20, 30, 40])  # (4,)

# b se aplica a cada fila de A por broadcasting
C = A + b
\end{lstlisting}

\begin{agrobox}{Ejercicio (medio): fertilizaci√≥n por franjas}
Simula un lote \texttt{A} de 100x100 y un vector \texttt{b} de 100 valores
(fertilizaci√≥n por columna). Usa broadcasting para obtener el lote ajustado \texttt{A+b}.
\end{agrobox}

\subsection{Reducciones y el par√°metro \texttt{axis}}
Reducciones como \texttt{sum}, \texttt{mean}, \texttt{max} colapsan dimensiones.
El argumento \texttt{axis} indica sobre qu√© eje reduces.

\begin{lstlisting}[language=Python, caption={Reducciones por eje}]
import numpy as np

M = np.random.rand(3, 4)

total = M.sum()            # escalar: suma todo
por_fila = M.mean(axis=1)  # (3,) promedio por fila
por_col  = M.mean(axis=0)  # (4,) promedio por columna
\end{lstlisting}

\begin{conceptbox}{Lectura r√°pida}
\texttt{axis=0} suele significar ``colapsar filas'' (resultado por columna).
\texttt{axis=1} suele significar ``colapsar columnas'' (resultado por fila).
\end{conceptbox}

\subsection{M√°scaras booleanas (boolean indexing)}
Una condici√≥n sobre un array produce un array booleano (True/False) del mismo shape, que puede usarse para seleccionar elementos.

\begin{lstlisting}[language=Python, caption={M√°scara + conteo de celdas en sequ√≠a}]
import numpy as np

humedad = np.random.rand(100, 100)
sequia = humedad < 0.2

area_sequia = np.sum(sequia)  # cuenta True
\end{lstlisting}

\subsection{\texttt{np.where}: decisiones vectorizadas}
\texttt{np.where} permite asignar valores en funci√≥n de una condici√≥n, por celda, sin iterar manualmente.

\begin{lstlisting}[language=Python, caption={Mapa de acciones con np.where}]
import numpy as np

humedad = np.random.rand(10, 10)
acciones = np.where(humedad < 0.2, "R", ".")  # R=regar, .=normal
\end{lstlisting}

\begin{agrobox}{Ejercicio (dif√≠cil): pol√≠tica de riego y drenaje}
Crea \texttt{acciones} con 3 clases:
\begin{itemize}
\item \texttt{"R"} si \texttt{humedad < 0.2}
\item \texttt{"D"} si \texttt{humedad > 0.85}
\item \texttt{"."} en otro caso
\end{itemize}
y calcula los porcentajes de cada clase usando m√°scaras.
\end{agrobox}

% =====================================================
% Cap√≠tulo: Introducci√≥n esencial a Matplotlib
% =====================================================
\section{Cap√≠tulo: Visualizaci√≥n esencial con Matplotlib (desde NumPy)}

La visualizaci√≥n es parte del flujo cient√≠fico: permite validar datos, detectar outliers y comunicar resultados.
Como ya estamos usando NumPy (\texttt{np}), el siguiente paso natural es graficar con Matplotlib a trav√©s de \texttt{matplotlib.pyplot}.

\begin{conceptbox}{Objetivo}
Aprender lo m√≠nimo indispensable para:
\begin{itemize}
\item Graficar series 1D (l√≠neas).
\item Comparar mediciones (scatter/barras).
\item Visualizar una matriz 2D (heatmap con \texttt{imshow}).
\item Guardar gr√°ficos en \texttt{reports/} con \texttt{savefig}.
\end{itemize}
\end{conceptbox}

\subsection{\texttt{pyplot}: la interfaz r√°pida}
El flujo t√≠pico con \texttt{pyplot} es: crear gr√°fico, etiquetar, y guardar/mostrar.

\subsection{Gr√°fico de l√≠nea (1D)}

\begin{lstlisting}[language=Python, caption={L√≠nea: serie 1D con etiquetas y leyenda}]
import numpy as np # importa la libreria numpy, con alias np
import matplotlib.pyplot as plt # importa la libreria matplotlib con su sublibrer√≠a pyplot y alias plt

# Simulaci√≥n: 24 mediciones de humedad (una por hora)
# Eval√∫a la funci√≥n en una l√≠nea que est√° en el intervalo [0,2pi)
# Con 24 puntos, no se incluye el extremo derecho

hum = 40 + 10*np.sin(np.linspace(0, 2*np.pi, 24))


plt.plot(hum, label="Humedad (%)")  # Grafica la curva
plt.title("Humedad por hora")       # T√≠tulo
plt.xlabel("Hora")                  # Nombre del eje x
plt.ylabel("Humedad (%)")           # Nombre del eje y
plt.legend("Np") # leyenda
plt.show()                          # Muestra la gr√°fica
\end{lstlisting}

El gr√°fico se puede apreciar en la figura \ref{fig:hum}

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.3]{humedad.png}
    \label{fig:hum}
    \caption{Gr√°fica generada con los comandos de python}
\end{figure}

\subsection{Scatter (dispersi√≥n): detectar relaci√≥n y outliers}

Diagrama de dispersi√≥n generado por Scatter de python, ver figura \ref{fig:scater}
\begin{lstlisting}[language=Python, caption={Scatter: temperatura vs humedad}]
import numpy as np
import matplotlib.pyplot as plt

np.random.seed(7) # Utiliza una semilla, para que los datos no cambien
temp = 20 + 10*np.random.rand(100) # Genera una serie aleatoria de temperaturas
hum  = 30 + 40*np.random.rand(100) # Genera una serie aleatoria de humedades

plt.scatter(temp, hum, s=18) # Utiliza el tipo de gr√°fica scatter
plt.title("Relaci√≥n temperatura vs humedad")
plt.xlabel("Temperatura (C)")
plt.ylabel("Humedad (%)")
plt.show()
\end{lstlisting}
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.3]{scater.png}
    \caption{Diagrama de dispersi√≥n, generada con numpy}
    \label{fig:scater}
\end{figure}
\subsection{Heatmap (2D) con \texttt{imshow} + \texttt{colorbar}}
Para una matriz (por ejemplo, mapa de humedad), \texttt{imshow} la dibuja como imagen y \texttt{colorbar} a√±ade la escala de colores.

\begin{lstlisting}[language=Python, caption={Heatmap: humedad 2D con colorbar}]
import numpy as np
import matplotlib.pyplot as plt

humedad = np.random.rand(50, 50) # Genera una matriz de valores aleatorios

plt.imshow(humedad, cmap="viridis", interpolation="nearest")  # Muestra el mapa de calor
plt.colorbar()                                                # Colorea
plt.title("Mapa de humedad (50x50)")
plt.show()
\end{lstlisting}

Se puede apreciar el mapa de calor en la figura \ref{fig:calor}
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.3]{calor.png}
    \caption{Mapa de calor con numpy}
    \label{fig:calor}
\end{figure}
\subsection{Guardar gr√°ficos con \texttt{savefig}}
Para incluir resultados en el reporte, lo ideal es guardar figuras en archivos (por ejemplo PNG) usando \texttt{savefig}.

\begin{lstlisting}[language=Python, caption={Guardar figura a mapa\_humedad.png}]
import os # Importa comandos del sistema
import numpy as np
import matplotlib.pyplot as plt

os.makedirs("reports", exist_ok=True) # Verifica que exista la carpeta reports

humedad = np.random.rand(50, 50)

plt.imshow(humedad, cmap="viridis", interpolation="nearest")
plt.colorbar()
plt.title("Mapa de humedad (50x50)")

plt.savefig("reports/mapa_humedad.png", dpi=150, bbox_inches="tight")  # Guarda la figura con el nombre mapa_humedad.png en la carpeta reports
\end{lstlisting}

\begin{warningbox}{Tip pr√°ctico}
Si vas a usar \texttt{plt.show()}, guarda antes con \texttt{plt.savefig(...)} para evitar perder la figura en algunos flujos de ejecuci√≥n.
\end{warningbox}

\subsection{Ejercicios}
\begin{agrobox}{Ejercicio (b√°sico): dos parcelas}
Grafica dos series (dos parcelas) en la misma figura usando \texttt{label=} y \texttt{plt.legend()}.
\end{agrobox}

\begin{agrobox}{Ejercicio (medio): mapa de sequ√≠a}
Dada una matriz \texttt{humedad}, crea \texttt{sequia = humedad < 0.2} y grafica esa m√°scara con \texttt{imshow}.
\end{agrobox}

\begin{agrobox}{Ejercicio (dif√≠cil): diagn√≥stico 2x2}
Construye una figura con 4 subgr√°ficos:
\begin{itemize}
\item mapa de humedad,
\item m√°scara de sequ√≠a,
\item m√°scara de inundaci√≥n,
\item mapa de acciones (convertido a n√∫meros).
\end{itemize}
Gu√°rdala como \texttt{reports/diagnostico.png}.
\end{agrobox}

% =====================================================
\section*{Prefacio: de scripts a sistemas que escalan}
Vamos a profesionalizar el c√≥digo: validar datos, medir rendimiento y usar NumPy para operar por bloques.

\begin{conceptbox}{Definition of Done (DoD)}
Al terminar, debes tener:
\begin{itemize}
\item Un validador \textit{fail fast} para registros de sensores.
\item Un pipeline CSV sucio \(\rightarrow\) CSV limpio (sin pandas).
\item Un benchmark reproducible con \texttt{time.perf\_counter()} (loop vs vectorizado).
\item Un mapa de lote (matriz) con m√°scaras booleanas y \texttt{np.where}.
\item Un reporte en \LaTeX{} (manual en Semana 2).
\end{itemize}
\end{conceptbox}

\newpage

% =====================================================
\section{Cap√≠tulo II: Programaci√≥n defensiva (Fail Fast)}

\subsection{Por qu√© esto es ingenier√≠a}
Un sensor puede fallar. Un archivo puede venir mal. Un dato puede ser imposible.
Si el sistema no valida, el error se propaga.

\begin{conceptbox}{Regla}
Valida temprano, falla claro y registra qu√© descartaste.
\end{conceptbox}

\subsection{Programa 1: Validador con guard clauses (comentado)}

\begin{lstlisting}[language=Python, caption={Programa 1: Validaci√≥n fail fast con guard clauses}]
# Programa 1:
# Este script ense√±a a validar datos antes de procesarlos.
# La idea es que el sistema "falle r√°pido" (fail fast) con mensajes claros,
# en lugar de continuar con datos inv√°lidos y generar resultados incorrectos.

from __future__ import annotations


def validar_sensor_row(row: dict) -> dict:
    """
    Recibe un registro tipo dict y lo valida.
    Si algo est√° mal: lanza ValueError (falla r√°pido).
    Si todo est√° bien: devuelve un dict limpio/normalizado.

    Formato esperado:
      {"id": "SENSOR_01", "temp": 24.2, "hum": 55}
    """

    # 1) Validar existencia y calidad del ID
    # Guard clause: si no hay id, no seguimos.
    if "id" not in row or not str(row["id"]).strip():
        raise ValueError("Falta 'id' o est√° vac√≠o.")

    # Normalizaci√≥n: quitar espacios y usar may√∫sculas
    sensor_id = str(row["id"]).strip().upper()

    # 2) Validar temperatura
    # Guard clause: debe existir la llave
    if "temp" not in row:
        raise ValueError("Falta 'temp' (temperatura).")

    # Guard clause: debe ser num√©rica
    if not isinstance(row["temp"], (int, float)):
        raise ValueError("'temp' debe ser num√©rica (int/float).")

    temp = float(row["temp"])

    # Guard clause: rango razonable para sensores agr√≠colas
    if temp < -10 or temp > 60:
        raise ValueError("'temp' fuera de rango [-10, 60].")

    # 3) Validar humedad
    if "hum" not in row:
        raise ValueError("Falta 'hum' (humedad).")

    if not isinstance(row["hum"], (int, float)):
        raise ValueError("'hum' debe ser num√©rica (int/float).")

    hum = float(row["hum"])

    if hum < 0 or hum > 100:
        raise ValueError("'hum' fuera de rango [0, 100].")

    # Si llegamos aqu√≠: el registro es v√°lido.
    # Devolvemos una versi√≥n limpia.
    return {"id": sensor_id, "temp": temp, "hum": hum}


def main() -> None:
    # Dataset simulado: incluye registros v√°lidos e inv√°lidos a prop√≥sito.
    datos = [
        {"id": "sensor_01", "temp": 24.2, "hum": 55},  # v√°lido
        {"id": "SENSOR_02", "temp": 25.1, "hum": 56},  # v√°lido
        {"id": "SENSOR_XX", "temp": 999, "hum": 10},   # inv√°lido (temp)
        {"id": "", "temp": 23.0, "hum": 50},          # inv√°lido (id)
        {"id": "SENSOR_03", "temp": "N/A", "hum": 40}, # inv√°lido (tipo temp)
    ]

    validos = 0
    motivos = {}

    # Recorremos el dataset, validamos y contamos errores por motivo.
    for row in datos:
        try:
            _ = validar_sensor_row(row)
            validos += 1
        except ValueError as e:
            motivo = str(e)
            motivos[motivo] = motivos.get(motivo, 0) + 1

    print(f"Validos: {validos}/{len(datos)}")
    print("Motivos de descarte:")
    for k, v in sorted(motivos.items(), key=lambda x: x[1], reverse=True):
        print(f"  - {k}: {v}")


if __name__ == "__main__":
    main()
\end{lstlisting}

\begin{agrobox}{Ejercicio 1}
Modifica el validador para aceptar \texttt{hum} como string num√©rico (por ejemplo ``"45"``) convirti√©ndolo a float, pero seguir rechazando ``"N/A"``.
\end{agrobox}

\newpage

% =====================================================
\section{Cap√≠tulo III: CSV sucio \texorpdfstring{\(\rightarrow\)}{->} CSV limpio (sin pandas)}
\subsection{Por qu√© sin pandas}
En esta semana, el objetivo es entender el pipeline y las validaciones sin ``magia''.

\subsection{Programa 2: Generar un CSV sucio (comentado)}

\begin{lstlisting}[language=Python, caption={Programa 2: Generar un CSV sucio (con errores intencionales)}]
# Programa 2:
# Genera un archivo CSV con datos "sucios" (errores intencionales).
# Esto simula el mundo real: sensores que env√≠an N/A, vac√≠os o valores imposibles.

from __future__ import annotations

import random


def generar_csv_sucio(path: str, n: int = 40) -> None:
    # Semilla para reproducibilidad: mismos datos en cada ejecuci√≥n
    random.seed(7)

    sensores = ["SENSOR_01", "SENSOR_02", "SENSOR_03", "SENSOR_04"]

    # Abrimos el archivo en modo escritura y ponemos header
    with open(path, "w", encoding="utf-8") as f:
        f.write("id_sensor,fecha,temperatura,humedad\n")

        for i in range(n):
            s = random.choice(sensores)
            fecha = f"2026-01-01 00:{i:02d}:00"

            # Inyectamos errores en ciertas filas (por √≠ndice)
            if i in (5, 17):
                temp = "N/A"      # error: no num√©rico
            elif i in (8,):
                temp = 999        # error: imposible
            else:
                temp = round(random.uniform(18, 35), 1)

            if i in (3, 22):
                hum = ""          # error: faltante
            elif i in (12,):
                hum = 200         # error: fuera de rango
            else:
                hum = random.randint(30, 90)

            # Escribimos la fila al CSV
            f.write(f"{s},{fecha},{temp},{hum}\n")


if __name__ == "__main__":
    generar_csv_sucio("data/raw/sensores_sucio.csv", n=40)
    print("OK: generado data/raw/sensores_sucio.csv")
\end{lstlisting}

\subsection{Programa 3: Limpiar el CSV (comentado)}

\begin{lstlisting}[language=Python, caption={Programa 3: Limpieza CSV sin pandas + reporte de errores}]
# Programa 3:
# Lee un CSV sucio l√≠nea por l√≠nea, valida y escribe un CSV limpio.
# Adem√°s genera un reporte de limpieza (cu√°ntos descart√≥ y por qu√©).

from __future__ import annotations


def validar_sensor_row(row: dict) -> dict:
    # Reutilizamos el validador (versi√≥n corta, misma l√≥gica del Programa 1)
    if "id" not in row or not str(row["id"]).strip():
        raise ValueError("Falta 'id' o est√° vac√≠o.")

    sensor_id = str(row["id"]).strip().upper()

    if "temp" not in row:
        raise ValueError("Falta 'temp'.")
    if not isinstance(row["temp"], (int, float)):
        raise ValueError("'temp' debe ser num√©rica.")
    temp = float(row["temp"])
    if temp < -10 or temp > 60:
        raise ValueError("'temp' fuera de rango [-10, 60].")

    if "hum" not in row:
        raise ValueError("Falta 'hum'.")
    if not isinstance(row["hum"], (int, float)):
        raise ValueError("'hum' debe ser num√©rica.")
    hum = float(row["hum"])
    if hum < 0 or hum > 100:
        raise ValueError("'hum' fuera de rango [0, 100].")

    return {"id": sensor_id, "temp": temp, "hum": hum}


def parse_row(linea: str) -> dict:
    # Convertimos una l√≠nea CSV en un dict con tipos correctos
    parts = linea.strip().split(",")
    if len(parts) != 4:
        raise ValueError("Fila corrupta: columnas != 4")

    id_sensor, fecha, temp_str, hum_str = parts

    # Temperatura: detectar faltantes o N/A
    if temp_str == "" or temp_str.upper() == "N/A":
        raise ValueError("Temperatura faltante o N/A")
    temp = float(temp_str)

    # Humedad: detectar faltantes
    if hum_str == "":
        raise ValueError("Humedad faltante")
    hum = float(hum_str)

    # Validaci√≥n de rangos (fail fast)
    _ = validar_sensor_row({"id": id_sensor, "temp": temp, "hum": hum})

    # Si pasa: devolvemos un registro con fecha incluida
    return {"id": id_sensor.strip().upper(), "fecha": fecha, "temp": temp, "hum": hum}


def limpiar_csv(in_path: str, out_path: str, report_path: str) -> None:
    total = 0
    validos = 0
    motivos = {}

    # Leemos el CSV de entrada y escribimos uno nuevo (limpio)
    with open(in_path, "r", encoding="utf-8") as fin, open(out_path, "w", encoding="utf-8") as fout:
        header = fin.readline().strip()
        fout.write(header + "\n")

        for linea in fin:
            total += 1
            try:
                row = parse_row(linea)
                fout.write(f"{row['id']},{row['fecha']},{row['temp']},{row['hum']}\n")
                validos += 1
            except Exception as e:
                m = str(e)
                motivos[m] = motivos.get(m, 0) + 1

    # Escribir reporte de limpieza
    top = sorted(motivos.items(), key=lambda x: x[1], reverse=True)[:3]
    with open(report_path, "w", encoding="utf-8") as frep:
        frep.write("=== REPORTE LIMPIEZA CSV ===\n")
        frep.write(f"Total filas (sin header): {total}\n")
        frep.write(f"Validas: {validos}\n")
        frep.write(f"Descartadas: {total - validos}\n\n")
        frep.write("Top 3 motivos:\n")
        for motivo, c in top:
            frep.write(f"- {motivo}: {c}\n")


if __name__ == "__main__":
    # Nota: este script asume que el CSV sucio ya existe.
    # En el taller, primero se ejecuta Programa 2 para generarlo.
    limpiar_csv(
        in_path="data/raw/sensores_sucio.csv",
        out_path="data/processed/sensores_limpio.csv",
        report_path="reports/reporte_limpieza.txt",
    )
    print("OK: generado data/processed/sensores_limpio.csv y reports/reporte_limpieza.txt")
\end{lstlisting}

\begin{agrobox}{Ejercicio 2}
Extiende \texttt{parse\_row()} para registrar tambi√©n un error cuando la fecha est√© vac√≠a o no tenga el formato \texttt{YYYY-MM-DD HH:MM:SS}.
\end{agrobox}

\newpage

% =====================================================
\section{Cap√≠tulo IV: HPC con NumPy ‚Äî benchmark (loop vs vectorizaci√≥n)}

\subsection{Por qu√© medir}
Si no mides, solo est√°s adivinando.
Para comparar dos enfoques, necesitas un benchmark repetible.

\subsection{Programa 4: Benchmark con \texttt{time.perf\_counter()} (comentado)}

\begin{lstlisting}[language=Python, caption={Programa 4: Benchmark con \texttt{time.perf\_counter()}}]
# Programa 4:
# Compara el rendimiento de un bucle for vs una operaci√≥n vectorizada en NumPy.
# Se usa time.perf_counter() porque ofrece alta resoluci√≥n para medir tiempos.

from __future__ import annotations

import time
import numpy as np


def loop_for(x: np.ndarray) -> np.ndarray:
    # Este enfoque hace 1 mill√≥n de iteraciones en Python.
    # Cada iteraci√≥n tiene overhead del int√©rprete.
    y = np.empty_like(x)
    for i in range(x.shape[0]):
        y[i] = np.sin(x[i]) + np.cos(x[i])
    return y


def vectorizado(x: np.ndarray) -> np.ndarray:
    # Este enfoque delega el trabajo a NumPy (internamente C optimizado).
    # Opera sobre todo el array sin iterar expl√≠citamente en Python.
    return np.sin(x) + np.cos(x)


def main() -> None:
    n = 1_000_000
    x = np.random.rand(n).astype(np.float64)

    # Medici√≥n for-loop
    t0 = time.perf_counter()
    y1 = loop_for(x)
    t_for = time.perf_counter() - t0

    # Medici√≥n vectorizada
    t0 = time.perf_counter()
    y2 = vectorizado(x)
    t_vec = time.perf_counter() - t0

    # Validaci√≥n num√©rica: deben ser muy parecidos
    diff = float(np.max(np.abs(y1 - y2)))

    # Speedup: cu√°ntas veces es m√°s r√°pido lo vectorizado
    speedup = t_for / t_vec if t_vec > 0 else float("inf")

    print(f"Tiempo for-loop:    {t_for:.4f} s")
    print(f"Tiempo vectorizado: {t_vec:.4f} s")
    print(f"Speedup:            {speedup:.2f}x")
    print(f"Max diff:           {diff:.6e}")


if __name__ == "__main__":
    main()
\end{lstlisting}

\begin{agrobox}{Ejercicio 3}
Ejecuta el benchmark 3 veces. Anota los 3 speedups y reporta el promedio en tu PDF.
\end{agrobox}

\newpage

% =====================================================
\section{Cap√≠tulo IV: L√≥gica espacial con matrices (m√°scaras + np.where)}

Las m√°scaras booleanas permiten seleccionar celdas sin usar \texttt{if} por celda.

\subsection{Programa 5: Mapa de lote + acciones con \texttt{np.where} (comentado)}

\begin{lstlisting}[language=Python, caption={Programa 5: Mapa de lote (200x200) con m√°scaras y \texttt{np.where}}]
# Programa 5:
# Simula un lote como una matriz de humedad (200x200).
# Calcula sequ√≠a/inundaci√≥n usando m√°scaras booleanas.
# Luego decide acciones por celda con np.where().

from __future__ import annotations

import numpy as np


def render_ascii(mapa: np.ndarray, step: int = 10) -> str:
    """
    Render ASCII para ver un mapa grande en consola.
    step=10 significa que "muestreamos" 1 de cada 10 celdas (reduce tama√±o).
    """
    lines = []
    for r in range(0, mapa.shape[0], step):
        lines.append("".join(mapa[r, ::step].tolist()))
    return "\n".join(lines)


def main() -> None:
    np.random.seed(7)

    # Matriz 200x200 con valores en [0,1): simula humedad normalizada
    humedad = np.random.rand(200, 200)

    # Umbrales de decisi√≥n
    umbral_sequia = 0.2
    umbral_inund = 0.85

    # M√°scaras: arrays booleanos (True/False) del mismo tama√±o
    sequia = humedad < umbral_sequia
    inundacion = humedad > umbral_inund

    # Porcentajes: mean() de booleanos equivale a proporci√≥n de True
    pct_sequia = 100.0 * float(sequia.mean())
    pct_inund = 100.0 * float(inundacion.mean())

    # Presupuesto h√≠drico:
    # Queremos subir humedad a 0.5 solo donde est√© por debajo de 0.5.
    objetivo = 0.5
    agua_por_celda = np.where(humedad < objetivo, (objetivo - humedad), 0.0)
    agua_total = float(np.sum(agua_por_celda))

    # Acciones por celda (caracter):
    # R = regar (sequia)
    # D = drenaje (inundaci√≥n)
    # . = normal
    acciones = np.where(sequia, "R", np.where(inundacion, "D", "."))

    print("=== Resumen lote (200x200) ===")
    print(f"% sequ√≠a (<{umbral_sequia}):     {pct_sequia:.2f}%")
    print(f"% inundaci√≥n (>{umbral_inund}): {pct_inund:.2f}%")
    print(f"Agua total requerida (objetivo={objetivo}): {agua_total:.2f}")

    print("\nMapa ASCII (muestreo cada 10 celdas):")
    print(render_ascii(acciones, step=10))


if __name__ == "__main__":
    main()
\end{lstlisting}

\begin{agrobox}{Ejercicio 4 (medio)}
Cambia los umbrales y analiza c√≥mo cambia:
\begin{itemize}
\item \% de sequ√≠a
\item \% de inundaci√≥n
\item agua total requerida
\end{itemize}
Registra 2 configuraciones y comp√°ralas en tu PDF.
\end{agrobox}

\newpage

% =====================================================
\section{Introducci√≥n a LaTeX: Documentos Profesionales en Ingenier√≠a}

A partir de esta semana, entregar√°s tus reportes en \textbf{LaTeX} en lugar de editores visuales como Word o Google Docs. ¬øPor qu√©? Porque LaTeX es el est√°ndar en publicaciones cient√≠ficas, ingenier√≠a y documentaci√≥n t√©cnica.

\subsection{¬øQu√© es LaTeX?}

LaTeX es un \textit{sistema de composici√≥n de documentos} basado en texto plano. A diferencia de los editores "WYSIWYG" (What You See Is What You Get), en LaTeX \textbf{describes} c√≥mo debe verse el documento mediante comandos, y el sistema lo compila autom√°ticamente en un PDF profesional.

Piensa en LaTeX como \textbf{c√≥digo para documentos}:
\begin{itemize}
    \item Escribes instrucciones en un archivo \texttt{.tex} (texto plano).
    \item El compilador \texttt{xelatex} o \texttt{pdflatex} las convierte en un PDF final.
    \item El resultado es consistente, elegante y reproducible.
\end{itemize}

\subsection{LaTeX vs. Editores tradicionales}

\begin{center}
\begin{tabular}{@{}p{6cm}p{6cm}@{}}
\toprule
\textbf{Editor visual (Word/Docs)} & \textbf{LaTeX} \\
\midrule
Formato manual (click en cada elemento) & Formato autom√°tico por comandos \\
Las f√≥rmulas se descuadran al editar & Las f√≥rmulas siempre quedan perfectas \\
Referencias a figuras hay que actualizarlas a mano & Referencias se actualizan autom√°ticamente \\
Dif√≠cil versionar cambios & Compatible con Git (texto plano) \\
Cada colaborador puede cambiar el formato & El formato es consistente por dise√±o \\
\bottomrule
\end{tabular}
\end{center}

\subsection{¬øPor qu√© LaTeX en este curso?}

En ingenier√≠a de software e inteligencia artificial, necesitas documentar:
\begin{itemize}
    \item \textbf{C√≥digo fuente} con sintaxis resaltada.
    \item \textbf{F√≥rmulas matem√°ticas} (como funciones de costo en Machine Learning).
    \item \textbf{Tablas con resultados} de experimentos o datasets.
    \item \textbf{Gr√°ficos y diagramas} referenciados autom√°ticamente.
\end{itemize}

LaTeX maneja todo esto de forma profesional y estandarizada. Adem√°s, tus reportes quedan \textbf{versionados en Git} junto con tu c√≥digo, permitiendo rastrear cambios hist√≥ricos.

\subsection{Tu primer documento LaTeX}

Un documento m√≠nimo tiene esta estructura:

\begin{lstlisting}[language=TeX, caption={Estructura b√°sica de LaTeX}]
\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}

\title{Reporte de An√°lisis de Sensores}
\author{Tu Nombre}
\date{\today}

\begin{document}

\maketitle

\section{Introducci√≥n}
Este reporte presenta el an√°lisis de 1440 lecturas de sensores agr√≠colas.

\section{Resultados}
Se detectaron 3 periodos cr√≠ticos de temperatura superior a 30¬∞C.

\end{document}
\end{lstlisting}

Al compilar con \texttt{xelatex reporte.tex}, obtienes un PDF profesional con:
\begin{itemize}
    \item Portada autom√°tica.
    \item Numeraci√≥n de secciones.
    \item M√°rgenes, tipograf√≠a y espaciado estandarizados.
\end{itemize}

\subsection{Compilaci√≥n en Codespaces}

En tu entorno de desarrollo ejecutas:

\begin{lstlisting}[language=bash]
xelatex reporte.tex
\end{lstlisting}

Esto genera \texttt{reporte.pdf} junto con archivos auxiliares (\texttt{.aux}, \texttt{.log}). Solo el \texttt{.tex} y el \texttt{.pdf} se versiona en Git [web:41].

\subsection{Ventajas para ingenieros de datos}

\begin{itemize}
    \item \textbf{Reproducibilidad}: El mismo \texttt{.tex} genera el mismo PDF en cualquier sistema.
    \item \textbf{Versionamiento}: Git muestra cambios l√≠nea por l√≠nea en el c√≥digo LaTeX.
    \item \textbf{Automatizaci√≥n}: Puedes generar reportes desde scripts Python insertando resultados din√°micamente.
    \item \textbf{Profesionalismo}: Papers acad√©micos, tesis y documentaci√≥n t√©cnica usan LaTeX como est√°ndar.
\end{itemize}

En las pr√≥ximas semanas aprender√°s a incluir tablas de resultados, ecuaciones de modelos y fragmentos de c√≥digo Python en tus reportes LaTeX.

\newpage

% =====================================================
\section*{Reto Final Integrador (Semana 2)}

\begin{agrobox}{Artefactos m√≠nimos}
Debes dejar estos archivos en el repositorio:
\begin{itemize}
\item \texttt{data/raw/sensores\_sucio.csv}
\item \texttt{data/processed/sensores\_limpio.csv}
\item \texttt{reports/reporte\_limpieza.txt}
\item \texttt{reports/decision\_hidrica.txt} (resumen del lote)
\item \texttt{report/main.pdf}
\end{itemize}
\end{agrobox}

\begin{conceptbox}{Checklist Git}
\begin{itemize}
\item M√≠nimo 3 commits claros.
\item Los scripts se pueden ejecutar en orden sin errores.
\item El PDF existe y resume resultados.
\end{itemize}
\end{conceptbox}

\end{document}
